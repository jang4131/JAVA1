생성자 : 클래스를 객체로 만들어주는 메소드
	클래스명()를 생성자라고 한다.
	생성자는 이름 뒤에 소괄호가 있기 때문에 메소드와 똑같은 기능을 한다.
	하지만 생성자는 리턴을 사용할 수 없고, 리턴 타입을 지원하지 않기 때문에
	메소드라 부르지 않고 생성자라고 불러야 한다.

생성자의 역할
	1. 클래스 선언 후 필드를 선언하면 객체를 통해서 필드를 사용하게 된다.
	사용하기 위해서는 RAM이 필드를 기억해야 하며, 해당 클래스의 필드를
	메모리에 할당해주는 역할을 해주는 것이 바로 생성자이다.
	필드를 메모리에 할당한 후 주소값을 가지고 오기 때문에 new 클래스명()은
	통채로를 할당된 필드의 주소값으로 봐야한다.

	2. 초기화

클래스 사용
	클래스는 추상적인 개념이고, 필드에 접근하기 위해서는 구체적인 개념이 필요하다.
	이 구체적인 개념을 객체라고 부르며, 영어로 인스턴스 변수라고 부른다.
	따라서 아래와 같이 선언 후 필드에 접근하게 된다.

	클래스명 객체명 = new 클래스명();
	------ -----   -------------
	추상적   구체적   할당된 필드의 주소값

	추상적인 개념을 구체적인 개념으로 만드는 작업을 객체화라고 하며, 영어로
	인스턴스라고 한다. 객체화를 통해서 나온 객체를 인스턴스 변수라고 부른다.
	필드에 접근하기 위해서는 .(하위 연산자)를 사용해야 하며, 하위 연산자는
	반드시 주소값 뒤에 작성되어야 한다.

this
	하나의 클래스로부터 여러 객체가 생성된다.
	각 객체별로 같은 필드를 구성하고 있고, 특정 객체의 멤버변수에 접근하기 위해서는
	해당 객체가 가지고 있는 주소값이 필요하다. 소스코드 상에서 필드 안에 메소드를 선언할 때
	딱 한 번 선언하고, 그 안에서 멤버변수를 사용할 때 어떤 객체의 멤버변수인지를 알 수가 없다.
	따라서 객체가 메소드에 접근하면 가지고 있는 주소값을 해당 메소드에게 전달해주어야 하고,
	전달된 주소값을 this라는 변수가 받는다. 따라서 this.멤버변수로 사용해야 한다.
	하지만 매번 this.를 붙이기 번거롭기 때문에 생략이 가능하다.
------------------------------------------------------------------------------------
다형성(polymorphism) : 메소드의 성질
	1. 오버로딩(Overloading)
		매개변수의 개수 혹은 타입이 서로 다르면 같은 이름의 메소드로 선언할 수 있다.
	2. 오버라이딩(Overriding)
------------------------------------------------------------------------------------
Storage Class(저장기억부류)

	stack	heap	data영역
	
	지역변수		전역변수 / 정적변수(static)
	매개변수		

초기화	직접			자동
생명주기	}		new	  프로그램 종료시
보안성	상		중	  하


static
	모든 객체가 공유해야 할 요소의 자료형 앞에 작성한다.


-----------------------------------------------------------------------------------
클래스 배열
	클래스명[] 배열명 = new 클래스명[칸수];
	클래스명[] 배열명 = {
		new 생성자(),
		new 생성자(),
		...
	};

※ 배열을 new로 선언하면 모든 방은 자동으로 초기화된다.

---------------------------------------------------------------------------------------------------
상속(inheritance)
	1. 기존에 선언된 클래스의 필드를 새롭게 선언하는 클래스의 필드에서
	   사용하고 싶을 때
	2. 여러 클래스를 선언할 때 공통 필드가 많다면, 부모 클래스를 선언하고
	   공통 필드 선언 후 여러 클래스들에게 상속해주기 위함

상속 문법
	class A{
		A필드
	}

	class B extends A{
		A, B필드
	}
	
A : 부모 클래스, 상위 클래스, 슈퍼 클래스, 기반 클래스
B : 자식 클래스, 하위 클래스, 서브 클래스, 파생 클래스


*자식 필드 내에서 부모 필드에 접근할 때에는 super 키워드를 사용하고,
부모 생성자는 super()로 작성한다.

다형성(polymorphism)
	1.
	2. 오버라이딩(재정의)
		부모에 있는 메소드가 자식에서 수정이 필요하다면,
		똑같은 이름으로 자식에서 선언해준다.

		int data = 10;	//부모
		data = 20;	//자식

		System.out.println(data) //자식객체로 접근한 메소드.
					   결과는 자식 값.
------------------------------------------------------------------------
Casting
	up casting
		부모 타입에 자식 값을 넣는 형변환

		부모클래스명 부모객체명 = new 자식생성자();
		A a = new B();


	down casting
		※주의 : 자식 타입에 부모 값을 넣으면 오류이다.
		B b = (B)new A(); X
		자식 타입에 up casting된 객체를 넣는 형변환

		자식클래스명 자식객체명 = (자식클래스명)업캐스팅된객체명;
		A a = new B();
		B b = (B)a;

Casting을 사용하는 이유
	모든 자식 클래스를 관리하기 위해서는 하나의 타입으로 묶는 기법이 필요하다.
	따라서 모든 자식은 부모 타입이기 때문에 부모 타입의 객체로 자식 값을 전달받은 후
	필요에 따라 down casting을 통해 자식 필드에 접근하기 위해서 Casting을 사용한다.

타입 비교
	instanceof

	객체명 instnaceof 클래스명 : 객체가 클래스타입이면 true, 아니면 false
















